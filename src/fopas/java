package fopas.basics;

public interface FOAlias extends FOFormula
{
	Iterable<FOVariable> getArgs();
	int getCardinality();
	String getName();
}
package fopas.basics;

public interface FOConstant
{
	String getName();
}
package fopas.basics;

public class FOConstructionException extends Exception
{
	public FOConstructionException(String why)
	{
		super(why);
	}
}
package fopas.basics;

import java.util.Comparator;

public interface FOElement {	
	enum Type {
		Symbol,
		Integer,
		String
	}
	
	Type getType();
	Object getElement();
	Comparator<FOElement> getDefaultComparator(); // This is a major assumption that we can do this for anything that we can put in a set - but let's see how far we get with it.
	
	public static interface FOString extends FOElement
	{
		String getString();
	}
	public static interface FOInteger extends FOElement, Comparable<FOInteger>
	{
		int getInteger();
	}
	public static interface FOSymbol extends FOElement
	{
		String getName();
	}
}
package fopas.basics;

public interface FOEnumerableSet<T extends FOElement> extends Iterable<T>, FOSet<T>
{

}
package fopas.basics;

import fopas.basics.FOElement.FOInteger;

public interface FOFactory
{
	<T extends FOElement> FOSet<T> createSet();
	<T extends FOElement> FOSet<T> createSet(Iterable<T> elements);
	<T extends FOInteger> FOSet<T> createNaturals();
}
package fopas.basics;

import java.util.Set;

// This is just a marker atm.
public interface FOFiniteSet<T extends FOElement> extends FOEnumerableSet<T>
{

}
package fopas.basics;

import java.util.List;

public interface FOFormulaBuilder
{
	FOFormula buildFormula(String strform, FOStructure structure) throws FOConstructionException;
	FOAlias buildAlias(FOStructure structure, String name, List<FOVariable> args, String strform) throws FOConstructionException;
	
	FOFormula buildContradiction();
	FOFormula buildTautology();
}
package fopas.basics;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import fopas.FOFormulaBRImpl;
import openpas.basics.Expressions.Expression;
import openpas.basics.LogicalOps.LogicalAnd;
import openpas.basics.LogicalOps.LogicalOr;
import openpas.utils.SizedIterable;

public interface FOFormula
{
	boolean isNegated();
	boolean models(FOStructure structure) throws FOConstructionException;
	void checkFormula(FOStructure structure) throws FOConstructionException;
	Iterable<Map<FOVariable, FOElement>> getSatisfyingAssignments(FOStructure structure) throws FOConstructionException;
	FOFormula negate() throws FOConstructionException;
}
package fopas.basics;

/**
 * This is more than a formula set, less than formal system. It's meant to be a glorified formula set where also string extraction
 * operations can be embedded in (similar to the PAS interface).
 * @author Burak Cetin
 *
 */
public interface FOFormulaSystem
{

}
package fopas.basics;

import java.util.List;

public interface FOFunction
{
	FOElement eval(FOElement ... args);
	String getName();

	/**
	 * Get cardinality of the relation.
	 * @return -1 for any cardinality, >0 otherwise.
	 */
	int getCardinality();
	
	/**
	 * Optional in-fix representation - can be left null.
	 * @return
	 */
	String getInfix();
	
	int getPrecedence();	
}
package fopas.basics;

import java.util.Comparator;
import java.util.List;

public interface FOOrderedEnumerableSet<T extends FOElement> extends FOEnumerableSet<T>
{
	public FOOrderedEnumerableSet<T> constrainToRange(T first, T last);
	public int getConstrainedSize(FORelation<T> relation, List<FOTerm> terms);
	
	public Comparator<FOElement> getOrder();
	public T getFirstOrInfinite();
	public T getLastOrInfinite();
	
	public T getNextOrNull(T element);
	public T getPreviousOrNull(T element);
}
package fopas.basics;

// A range can be an integer or real-number range. And as such, it can be finite, infinite, enumerable or not.
// So we keep this interface as a separate entity because of that.
public interface FORange<T extends FOElement> 
{
	public T getStart();
	public T getStartOrInfinite(boolean includeStart);
	public boolean getIncludeStart();

	/**
	 * This may return null if this is an infinite set.
	 * @return the last element in this set according to the enumeration order.
	 */
	public T getEnd();
	public T getEndOrInfinite(boolean includeEnd);
	public boolean getIncludeEnd();	
}
package fopas.basics;

import java.util.List;
import java.util.Map;

public interface FORelation <T extends FOElement>
{
	String getName();
	boolean satisfies(FOElement ... args);
	String getInfix();
	
	/**
	 * Get cardinality of the relation.
	 * @return -1 for any cardinality, >0 otherwise.
	 */
	int getCardinality();
	
	int getPrecedence() throws FOConstructionException;
	
	/**
	 * This will return either itself or a new FOSet thats a subset of it. It'll consider the variable and the (partially assigned)
	 * terms it's given and find out what subset of the universe is needed.
	 * @param var
	 * @param universeSubset
	 * @param terms
	 * @param isComplemented Whether the returned set if a relative complement of the universeSubset (useful when relation is used negated).
	 * @return
	 */
	FOSet<FOElement> tryConstrain(FOVariable var, FOSet<FOElement> universeSubset,  List<FOTerm> terms, boolean isComplemented);
}
package fopas.basics;

public class FORuntimeException extends RuntimeException
{
	private static final long serialVersionUID = 77571481445410916L;

	public FORuntimeException(String reason)
	{
		super(reason);
	}
}
package fopas.basics;

import java.util.List;
import java.util.Set;

// We're only interested in enumarable sets in computations, so let's assume a set to be iterable up front - though this will change.
public interface FOSet<T extends FOElement>
{
	public int size(); // shared with Set, may return infinite (Integer.MAX_VALUE).
	
	public String getName();
	
	public boolean contains(Object o);
	
	/**
	 * This is to give the complement set: relativeSet \ this
	 * @param relativeSet
	 * @return A set containing elements that are in the relativeSet but not in this set.
	 */
	public FOSet<T> complement(FOSet<T> relativeSet);
	public default FOSet<T> complement(FOSet<T> relativeSet, boolean isComplement)
	{
		if(isComplement)
			return complement(relativeSet);
		else
			return this;
	}
}
package fopas.basics;

public interface FOStringiser
{
	String stringiseFormula(FOFormula form);
	String stringiseFormula(FOFormula form, int maxLen);
}
package fopas.basics;

import java.util.Map;

import fopas.FORuntime;

public interface FOStructure
{
	FOSet<FOElement> getUniverse();
	FOElement getConstantMapping(FOConstant foconst);
	FOElement setConstantMapping(FOConstant foconst, FOElement elt);
	Iterable<FORelation<FOElement>> getRelations();
	Iterable<FOFunction> getFunctions();
	Iterable<FOConstant> getConstants();

	Iterable<String> getAliases();
	FOFormula getAlias(String name);
	void addAlias(FOAlias formAlias) throws FOConstructionException;
	
	/**
	 * Answer whether this structure is a model of {@code form}.
	 * @param form
	 * @return
	 * @throws FOConstructionException 
	 */
	boolean models(FOFormula form) throws FOConstructionException;
	
	Iterable<Map<FOVariable, FOElement>> getSatisfyingAssignments(FOFormula form) throws FOConstructionException;
	Iterable<Map<FOVariable, FOElement>> getAssignments(FOFormula form) throws FOConstructionException;
	
	FORuntime getRuntime(); // This will come out of here later when I implement a proper runtime system, it's left here for convenience for now.
}
package fopas.basics;

import java.util.Map;

public interface FOTerm {

	/**
	 * 
	 * @param assignment
	 * @return True if the term accepts assignments.
	 */
	void assignVariables(FOStructure structure, Map<FOVariable, FOElement> assignment, boolean isPartial);
	
	FOElement getAssignment();
	
	enum TermType
	{
		VARIABLE,
		CONSTANT,
		FUNCTION
	}
	TermType getType();
}
package fopas.basics;

// This should probably really be a generic "UnionSet" as there's nothing universe
// specific here really.
public interface FOUnionSet<T extends FOElement> extends FOEnumerableSet<T>
{
	FOSet<T> getOriginalSubset(String name);
}
package fopas.basics;

public interface FOVariable
{
	String getName();
}
package fopas.basics;

public interface KnownIterable<T> extends Iterable<T>
{
	/**
	 * @return -1 if infinite or unknown
	 */
	int size();
}
package fopas.basics;

import java.util.regex.Pattern;

public class ValidationRules
{
	static final public String validName =  "[a-zA-Z]+[a-zA-Z_0-9]*"; 
	static final public String validInfixOp =  "[=+-/*^><~@]+"; 
	static final public String validLogicalOp =  "[|Â¬&]"; 
}
